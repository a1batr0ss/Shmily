#include <global.h>
#include <string.h>
#include "page.h"
#include "process.h"
#include "interrupt.h"
#include "print.h"

struct pcb *processes[NR_PROC];
struct pcb *cur_proc;
struct pcb *next_proc;
struct pcb *first_ready_proc;
struct pcb *last_ready_proc;
char cur_proc_idx;

void traverse_ready_queue();
unsigned int allocate_pid();

void init_process_info(struct pcb *proc, char *name_, unsigned int priority_)
{

    proc->priority = priority_;
    /* strcpy process's name */
    proc->pid = allocate_pid();
    proc->ticks = priority_;
    proc->elapsed_ticks = 0;
    proc->pagedir_pos = NULL;
    // proc->stack_top = (unsigned int*)((unsigned int)proc + paging::PAGE_SIZE);
}

void execute_func(proc_target func, void *args)
{
    enable_intr();
    func(args);
    // putstring("end execute_func\n");
    // asm volatile ("xchg %%bx, %%bx"::);
}

void create_process(struct pcb *proc, proc_target func_, void *args_)
{
    // proc->stack_top -= sizeof(struct thread_stack);
    // struct thread_stack *self_stack = (struct thread_stack)(proc->stack_top);
    proc->esp = (unsigned int*)((unsigned int)proc + sizeof(struct pcb) - sizeof(struct thread_stack));
    struct thread_stack *self_stack = &proc->self_stack;
    self_stack->ebp = 0;
    self_stack->ebx = 0;
    self_stack->esi = 0;
    self_stack->edi = 0;
    self_stack->eip = execute_func;
    self_stack->func = func_;
    self_stack->args = args_;
    proc->status = READY;  /* 默认即为0(RUNNING) */
    proc->next_ready = NULL;
}

unsigned int allocate_pid()
{
    static unsigned int pid = 0;
    pid++;
    return pid;
}

int append_ready_array(struct pcb *proc)
{
    /* Get a free slot in processes */
    for (unsigned char idx=0; idx<NR_PROC; idx++) {
        if (0 == processes[idx]) {
            processes[idx] = proc;
            return idx;
        }
    }
    return -1;  /* ready array is full, append failed. */
}

struct pcb* start_process(char *name, unsigned int priority, proc_target func, void *args, struct pcb *proc)
{
    init_process_info(proc, name, priority);
    create_process(proc, func, args);
    /* append to ready array */
    append_ready_array(proc);

    // last_ready_proc->next_ready = proc;
    // last_ready_proc = proc;
    // last_ready_proc->next_ready = first_ready_proc;  [> Make a circle. <]
    
    if (NULL == first_ready_proc)
        first_ready_proc = proc;

    if (NULL != last_ready_proc) {
        last_ready_proc->next_ready = proc;
        last_ready_proc = proc;
    } else {
        last_ready_proc = proc;
    }

    last_ready_proc->next_ready = first_ready_proc;
}

void switch_to(struct pcb *next)
{
    /* esp_next point to self_stack's top, so that we can pop the context to switch. */
    // asm volatile ("xchg %%bx, %%bx"::);
    unsigned int *retaddr = (unsigned int*)&next - 1;
    // puthex((unsigned int)retaddr);
    // putstring("\n");
    // puthex(*retaddr);
    // putstring("\n");
    // unsigned int esp_next = (unsigned int)next->esp;  /* Shouldn't use it, when the next->esp is update, the esp_next is not update immediately.(when next == cur) */
    
    asm volatile ("movl %%esp, %0" : "=m" (cur_proc->esp) : : "memory");
    // puthex((unsigned int)cur_proc);
    // putstring(" esp is ");
    // puthex((unsigned int)cur_proc->esp);
    // putstring("\n");
    // // puthex((unsigned int)cur_proc->esp);
    // // putstring("\n");
    // puthex((unsigned int)next->esp);  [> Without this statement, will cause fault(GP...) <]



    // asm volatile ("xchg %%bx, %%bx"::);
    /* esp cannot be constant. */
    // unsigned int esp_next_const = (unsigned int)next + sizeof(struct pcb) - sizeof(struct thread_stack);
    // unsigned int esp_next = (0==next->esp) ? esp_next_const : (unsigned int)next->esp;
    // puthex((unsigned int)next);
    // putstring("\n");
    // puthex(esp_next);
    // putstring("\n");
    // puthex((unsigned int)next->self_stack.func);
    // putstring("\n");
    // puthex((unsigned int)&next->self_stack);
    // putstring("\n");
    // puthex((unsigned int)&next->self_stack.ebp);
    // putstring("\n");
    // puthex((unsigned int)&next->self_stack.ebx);
    // putstring("\n");
    // puthex((unsigned int)&next->self_stack.edi);
    // putstring("\n");
    // puthex((unsigned int)&next->self_stack.esi);
    // unsigned int *esp_cur = (unsigned int)cur_proc + 
    prev = cur_proc;
    cur_proc = next;

    // putstring("will switch context.\n");
    // asm volatile ("xchg %%bx, %%bx"::);

    asm volatile ("pushl %1\n\t" \
                    "pushl %%esi\n\t" \
                    "pushl %%edi\n\t" \
                    "pushl %%ebx\n\t" \
                    "pushl %%ebp\n\t" \
                    "movl %%esp, %0\n\t" \  
                    /* As we need to recover the register in sequence, so we must save the esp's right position. */
                    "movl %2, %%esp\n\t" \
                    "popl %%ebp\n\t" \
                    "popl %%ebx\n\t" \
                    "popl %%edi\n\t" \
                    "popl %%esi\n\t" \
                    "ret" : "+m" (prev->esp) : "m" (*retaddr), "m" (cur_proc->esp) : "memory");
}

void schedule()
{
    /* 1. pick a ready process */
    // struct pcb *next = NULL;  [> Define the variable just for easily understand the switch_to function. <]
    // puthex(cur_proc_idx);  /* print function seems cannot output zero */
    // int old_pos = cur_proc_idx;  [> avoid the assignment below affect the compare in for. <]
    // for (int i=cur_proc_idx+1; i!=old_pos [> i!=cur_proc_idx i<NR_PROC <]; i++, i%=NR_PROC) {
        // [> roll-back <]
        // if ((NULL != processes[i]) && (RUNNING == processes[i]->status)) {
            // cur_proc_idx = i;
            // next = processes[i];
            
            // // if (next == cur_proc)
                // // return;
            // // cur_proc = processes[i];
            // // puthex((unsigned int)processes[i]);
            // // putstring("\n");
            // // puthex(processes[i]->pid);
            // break;
        // }  
    // }
    // putstring("cur is ");
    // puthex((unsigned int)cur_proc);
    // 如果是时间片到，则重新将入就绪队列
    // putstring("before append: ");
    // traverse_ready_queue();
    // if (cur_proc == NULL)
        // asm volatile ("xchg %%bx, %%bx"::);
    if (RUNNING == cur_proc->status) {
        if (NULL == last_ready_proc) {
            
        }
        last_ready_proc->next_ready = cur_proc;
        last_ready_proc = cur_proc;
        // cur_proc = first_ready_proc;
        last_ready_proc->next_ready = first_ready_proc;
    }
    // putstring("end append: ");
    // traverse_ready_queue();
    // putstring("next is ");
    // puthex((unsigned int)first_ready_proc);
    // putstring("\n status is ");
    // puthex((unsigned int)first_ready_proc->status);
    // asm volatile ("xchg %%bx, %%bx"::);

    // 要把要运行的弹出队列
    if (NULL != first_ready_proc) { 
        // next = first_ready_proc->next_ready;  [> Please ignore the name. <]
        // next->status = RUNNING;
        // first_ready_proc = next;
        next = first_ready_proc;
        // if (last_ready_proc != next)
        last_ready_proc->next_ready = first_ready_proc->next_ready; 
        next->status = RUNNING;
        first_ready_proc = first_ready_proc->next_ready;
        // putstring("switch to ");
        // puthex((unsigned int)next); 
    
        // puthex((unsigned int)next);
        // putstring("\n");
        // puthex((unsigned int)first_ready_proc);
        // asm volatile ("xchg %%bx, %%bx"::);
        /* 2. switch to the ready process which just picked. */
        switch_to(next);
    }
}

void deal_init_process()
{
    struct pcb *init_proc = (struct pcb*)0x80000;
    init_process_info(init_proc, "init", 2);
    cur_proc = init_proc;
    cur_proc_idx = -1;

    init_proc->status = RUNNING;
    
    /* Not schedule the init process later provisionally. */
    // first_ready_proc = init_proc;
    // last_ready_proc = init_proc;
    first_ready_proc = NULL;
    last_ready_proc = NULL;
}

void self_block(enum process_status stat)
{
    disable_intr();

    // puthex((unsigned int)first_ready_proc);
    // cur_proc->status = stat;
    // first_ready_proc->status = stat;
    cur_proc->status = stat;
    // putstring("In self_block ");
    // puthex((unsigned int)cur_proc);

    // putstring("In self_block: ");
    // puthex((unsigned int)prev);
    // putstring("\n");
    // puthex((unsigned int)cur_proc->next_ready);
    // putstring("\n\n"); 
    // prev->next_ready = cur_proc->next_ready;  [> Haven't use double linked list, the prev record the previous process. (Just swtiched process.) <]
    
    // prev->next_ready = first_ready_proc->next_ready;

    // puthex((unsigned int)first_ready_proc);
    // putstring("\n\n"); 
    // puthex((unsigned int)first_ready_proc->next_ready);
    // putstring("\n\n"); 

    // asm volatile ("xchg %%bx, %%bx"::);
    // first_ready_proc = first_ready_proc->next_ready;
    schedule(); 

    enable_intr();  /* Not always should enable interrupt, or disabled original. */
}

/* Haven't test it. */
void unblock_proc(struct pcb *proc)
{
    disable_intr();

    // if (NULL == proc)
        // asm volatile ("xchg %%bx, %%bx"::);
    // putstring("unblock: ");
    // traverse_ready_queue();
    proc->status = READY;
    last_ready_proc->next_ready = proc;
    proc->next_ready = first_ready_proc;
    last_ready_proc = proc;

    // traverse_ready_queue();

    enable_intr(); 
} 

void traverse_ready_queue()
{
    putstring("In ready ");
    putstring("ready queue is ");
    struct pcb *first = first_ready_proc;
    while (1) {
        if (first == last_ready_proc) {
        puthex((unsigned int)first);
            break;
        }
        puthex((unsigned int)first);
        putstring("-->");
        first = first->next_ready;
    }
    putstring("\n"); 
}

